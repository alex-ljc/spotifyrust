//! Refresh tokens aren't meant to expire, so they can be used as a persistent
//! authentication method without the need for user's interaction for oauth
//! requests. You still need to authenticate the usual way at least once to
//! obtain the refresh token, and you may need to obtain a new one if you change
//! the required scopes.
//!
//! The cache generated by `get_token` uses the refresh token under the hood to
//! automatically authenticate the user. This example shows how it's done
//! because sometimes it's not possible to use this cache file (a web server for
//! example).
//!
//! *Note*: refresh tokens can actually expire, [as the OAuth2 spec
//! indicates](https://tools.ietf.org/html/rfc6749#section-6), but this [hasn't
//! actually happened in months with some
//! tokens](https://github.com/felix-hilden/tekore/issues/86), so in the case of
//! Spotify it doesn't seem to revoke them at all.

use std::env;

use itertools::Itertools;
use rspotify::model::playlist;
use rspotify::model::PlaylistId;
use rspotify::prelude::*;

pub mod modules;
use crate::modules::playlists::add_tracks_to_playlist;
use crate::modules::playlists::update_everything;
use crate::modules::playlists::update_liked;
use crate::modules::playlists::update_recently_added;
use crate::modules::playlists::update_weekly_sample;
use crate::modules::playlists::clear_playlist;
use crate::modules::retrieve::print_album;
use crate::modules::retrieve::print_artist;
use crate::modules::retrieve::print_track;
use crate::modules::storage::LibraryDatabase;
use crate::modules::{storage, token};

pub static RECENTLY_ADDED: &str = "3BZP1mB69SWnSNCy4nfxXX";
pub static QUEUE_OF_SHIT: &str = "7kSoTKPlSLr0BKkFfOLhY2";
pub static RANDOMIZED_EVERYTHING: &str = "40DOSUlAs5lSqRqZ0KKS9R";
pub static WEEKLY_SAMPLE: &str = "6qYfQbHqlspyN18nF7bZB8";
pub static LIKED: &str = "1Eb6PKpnm0iz68zmNkT5rY";
pub static FILTER: &str = "46nfCqV4983BKRXFDEiMQ4";

#[tokio::main]
async fn main() {
    // You can use any logger for debugging.
    env_logger::init();

    let spotify = token::default_authcode().await.unwrap();
    spotify
        .refresh_token()
        .await
        .expect("couldn't refresh user token");

    let library = storage::LibraryDatabase::new("albums.json".to_owned(), "tracks.json".to_owned());

    let args: Vec<String> = env::args().collect();

    println!("{:?}", args);

    if args.len() == 2 {
        if args[1].eq("update") {
            library.update_all(&spotify).await;
        } else if args[1].eq("genres") {
            let genres = LibraryDatabase::compile_genres(
                library.retrieve_albums().values().cloned().collect_vec(),
            );
            for (genre, tracks) in genres {
                println!("{}: {}", genre, tracks.len());
            }
        }
    }
    if args[1].eq("update") {
        if args[2].eq("database") {
            library.update_all(&spotify).await;
        } else if args[2].eq("recently_added") {
            update_recently_added(&spotify, &library, RECENTLY_ADDED, 1000).await;
        } else if args[2].eq("everything") {
            update_everything(&spotify, &library, RANDOMIZED_EVERYTHING, 300, 1500).await;
            library.update_all(&spotify).await;
        } else if args[2].eq("weekly_sample") {
            update_weekly_sample(&spotify, &library, WEEKLY_SAMPLE, 200).await;
        } else if args[2].eq("liked") {
            update_liked(&spotify, &library, LIKED).await;
        }
    }

    if args.len() == 3 && args[1].eq("search") {
        let query = &args[2];
        let track_ids = library.search_songs(query);
        let stored_tracks = library.retrieve_tracks();
        let mut filtered_tracks = Vec::new();
        for track in track_ids {
            filtered_tracks.push(stored_tracks.get(&track).unwrap().clone());
        }
        let playlist_id = FILTER;
        clear_playlist(&spotify, playlist_id).await;
        add_tracks_to_playlist(&spotify, playlist_id, filtered_tracks).await;
        let _ = spotify
            .playlist_change_detail(
                PlaylistId::from_id(playlist_id).unwrap(),
                Some(query),
                None,
                None,
                None,
            )
            .await;
    }
    if args.len() == 4 {
        if args[1].eq("print") && args[2].eq("artist") {
            print_artist(&spotify, &args[3]).await;
        } else if args[1].eq("print") && args[2].eq("album") {
            print_album(&spotify, &args[3]).await;
        } else if args[1].eq("print") && args[2].eq("track") {
            print_track(&spotify, &args[3]).await;
        }
    }
}
