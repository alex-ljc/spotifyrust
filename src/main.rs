//! Refresh tokens aren't meant to expire, so they can be used as a persistent
//! authentication method without the need for user's interaction for oauth
//! requests. You still need to authenticate the usual way at least once to
//! obtain the refresh token, and you may need to obtain a new one if you change
//! the required scopes.
//!
//! The cache generated by `get_token` uses the refresh token under the hood to
//! automatically authenticate the user. This example shows how it's done
//! because sometimes it's not possible to use this cache file (a web server for
//! example).
//!
//! *Note*: refresh tokens can actually expire, [as the OAuth2 spec
//! indicates](https://tools.ietf.org/html/rfc6749#section-6), but this [hasn't
//! actually happened in months with som
//! tokens](https://github.com/felix-hilden/tekore/issues/86), so in the case of
//! Spotify it doesn't seem to revoke them at all.

use clap::arg;
use clap::Parser;
use clap::Subcommand;
use clap::ValueEnum;
use modules::playlists::clear_playlist;
use rspotify::prelude::*;

pub mod modules;
use crate::modules::playlists::add_searched_tracks;
use crate::modules::playlists::update_everything;
use crate::modules::playlists::update_liked;
use crate::modules::playlists::update_recently_added;
use crate::modules::playlists::update_weekly_sample;
use crate::modules::retrieve::print_album;
use crate::modules::retrieve::print_artist;
use crate::modules::retrieve::print_track;
use crate::modules::storage::LibraryDatabase;
use crate::modules::token;

pub static RECENTLY_ADDED: &str = "3BZP1mB69SWnSNCy4nfxXX";
pub static QUEUE_OF_SHIT: &str = "7kSoTKPlSLr0BKkFfOLhY2";
pub static RANDOMIZED_EVERYTHING: &str = "40DOSUlAs5lSqRqZ0KKS9R";
pub static WEEKLY_SAMPLE: &str = "6qYfQbHqlspyN18nF7bZB8";
pub static LIKED: &str = "1Eb6PKpnm0iz68zmNkT5rY";
pub static SEARCH: &str = "46nfCqV4983BKRXFDEiMQ4";
pub static TEST: &str = "5Zr1P0Q9xjrZnY1Ud5Aj1P";

/// Spotify Playlist Manager
#[derive(Parser)]
#[command(author, version, about, long_about = None)]
#[command(propagate_version = true)]
struct CLI {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, ValueEnum)]
enum IdType {
    Artist,
    Album,
    Track,
}

#[derive(Subcommand, Clone)]
enum Commands {
    /// Updates a playlist with the given info
    Update {
        /// Which playlist to update and how
        #[command(subcommand)]
        update_command: UpdateCommands,
    },

    /// Given a type and id prints the data from spotify
    Print {
        /// Id to print
        #[arg(short, long)]
        print_id: String,

        /// Type of id
        #[arg(short, long)]
        id_type: IdType,
    },

    /// Queries the database with the given string and adds the songs to a preset playlist
    Search {
        /// String to search
        #[arg(short, long)]
        query: String,

        /// Playlist ID
        #[arg(short, long, default_value_t = SEARCH.to_string())]
        playlist: String,

        /// Print
        #[arg(short, long, default_value_t = false)]
        do_print: bool,
    },

    /// Removes all songs in a playlist
    Clear {
        /// Playlist ID
        #[arg(short, long)]
        playlist: String,
    },
}

#[derive(Subcommand, Clone)]
enum UpdateCommands {
    /// Adds all new songs to the database
    Database,

    /// Updates a given playlist with recently liked songs and recently liked albums
    RecentlyAdded {
        /// Playlist ID
        #[arg(short, long, default_value = RECENTLY_ADDED)]
        playlist: String,

        /// Number of new songs
        #[arg(short, long, default_value_t = 1000)]
        num_new_songs: usize,

        /// Removes all songs in playlist
        #[arg(short, long, default_value_t = false)]
        reset_playlist: bool,
    },

    /// Updates a given playlist with a sample of recent and old songs from the database
    Everything {
        /// Playlist ID
        #[arg(short, long, default_value = RANDOMIZED_EVERYTHING)]
        playlist: String,

        /// Number of new songs
        #[arg(short, long, default_value_t = 200)]
        num_new_songs: usize,

        /// Number of old songs
        #[arg(short, long, default_value_t = 1800)]
        num_old_songs: usize,
    },

    /// Updates a given playlist with a random sample of songs
    WeeklySample {
        /// Playlist ID
        #[arg(short, long, default_value = WEEKLY_SAMPLE)]
        playlist: String,

        /// Number of songs
        #[arg(short, long, default_value_t = 200)]
        num_songs: usize,

        /// Removes all songs in playlist
        #[arg(short, long, default_value_t = false)]
        reset_playlist: bool,
    },

    /// Updates a given playlist
    Liked {
        /// Playlist ID
        #[arg(short, long, default_value = LIKED)]
        playlist: String,

        /// Removes all songs in playlist
        #[arg(short, long, default_value_t = false)]
        reset_playlist: bool,
    },
}

#[tokio::main]

async fn main() {
    // You can use any logger for debugging.
    env_logger::init();
    let rspot_dir = std::env::var("rspot_dir").unwrap_or_else(|_| {
        println!("Enter the rspot_dir");
        let mut rspotify_config_dir = String::new();
        std::io::stdin()
            .read_line(&mut rspotify_config_dir)
            .expect("Failed to read line");
        std::env::set_var("rspot_dir", rspotify_config_dir.trim());
        rspotify_config_dir.trim().to_string()
    });
    let rspot_dir = std::path::PathBuf::from(rspot_dir);

    let spotify = token::default_authcode(&rspot_dir).await.unwrap();
    spotify
        .refresh_token()
        .await
        .expect("couldn't refresh user token");

    let library = LibraryDatabase::new(
        rspot_dir.join("albums.json").to_str().unwrap().to_string(),
        rspot_dir.join("tracks.json").to_str().unwrap().to_string(),
        rspot_dir.join("liked.json").to_str().unwrap().to_string(),
    );

    let cli = CLI::parse();

    match &cli.command {
        Commands::Update { update_command } => match update_command {
            UpdateCommands::Database => library.update_all(&spotify).await,
            UpdateCommands::RecentlyAdded {
                playlist,
                num_new_songs,
                reset_playlist,
            } => update_recently_added(&spotify, &library, playlist, *num_new_songs).await,
            UpdateCommands::Everything {
                playlist,
                num_new_songs,
                num_old_songs,
            } => {
                update_everything(&spotify, &library, playlist, *num_new_songs, *num_old_songs)
                    .await
            }
            UpdateCommands::WeeklySample {
                playlist,
                num_songs,
                reset_playlist,
            } => update_weekly_sample(&spotify, &library, playlist, *num_songs).await,
            UpdateCommands::Liked {
                playlist,
                reset_playlist,
            } => update_liked(&spotify, &library, playlist).await,
        },

        Commands::Print { print_id, id_type } => match id_type {
            IdType::Artist => print_artist(&spotify, print_id).await,
            IdType::Album => print_album(&spotify, print_id).await,
            IdType::Track => print_track(&spotify, print_id).await,
        },
        Commands::Search {
            query,
            playlist,
            do_print,
        } => {
            add_searched_tracks(&spotify, &library, playlist, query, *do_print).await;
        }
        Commands::Clear { playlist } => {
            clear_playlist(&spotify, playlist).await;
        }
    }
}
